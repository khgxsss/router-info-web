import os
import json
from datetime import datetime, timedelta
from zoneinfo import ZoneInfo
import csv
import io

from sanic import Sanic, response
from sanic.request import Request
from sanic.exceptions import InvalidUsage
from sanic.exceptions import SanicException

try:
    import aiofiles           # íŒŒì¼ ë¹„ë™ê¸°ì“°ê¸°
    import aiomysql           # MySQL ë¹„ë™ê¸°
except ImportError:
    raise SystemExit("`pip install aiofiles aiomysql` ë¥¼ ë¨¼ì € ì‹¤í–‰í•˜ì„¸ìš”.")

APP_NAME = "RawBodyDailyLogger"
LOG_DIR = os.environ.get("LOG_DIR", "/home/rcn01/router_info")
KST = ZoneInfo("Asia/Seoul")  # GMT+9

# ====== MySQL ì—°ê²° ì •ë³´ (í™˜ê²½ë³€ìˆ˜ ì‚¬ìš© ê¶Œì¥) ======
DB_HOST = os.environ.get("DB_HOST", "14.50.159.2")
DB_PORT = int(os.environ.get("DB_PORT", "3306"))
DB_USER = os.environ.get("DB_USER", "rcn")
DB_PASS = os.environ.get("DB_PASS", "rcn01!0301")
DB_NAME = os.environ.get("DB_NAME", "ROUTER_INFO")  # ìš”ì²­ëŒ€ë¡œ DB ì´ë¦„ ë³€ê²½

app = Sanic(APP_NAME)

@app.exception(Exception)
async def handle_ex(request, exc):
    ts = datetime.now(tz=KST).strftime("%Y-%m-%d %H:%M:%S")
    msg = f"[{ts}] UNHANDLED: {repr(exc)}\n"
    try:
        async with aiofiles.open(os.path.join(app.ctx.log_dir, f"{datetime.now(tz=KST).strftime('%Y%m%d')}.log"), "ab") as f:
            await f.write(msg.encode())
    except:
        pass
    return response.json({"error": "internal_error", "detail": repr(exc)}, status=500)


@app.listener("before_server_start")
async def before_start(app, _):
    # ë¡œê·¸ ë””ë ‰í† ë¦¬ ì¤€ë¹„
    os.makedirs(LOG_DIR, exist_ok=True)
    app.ctx.log_dir = LOG_DIR

    # MySQL ì»¤ë„¥ì…˜ í’€
    app.ctx.pool = await aiomysql.create_pool(
        host=DB_HOST,
        port=DB_PORT,
        user=DB_USER,
        password=DB_PASS,
        db=DB_NAME,
        autocommit=True,
        minsize=1,
        maxsize=10,
        charset="utf8mb4",
    )


@app.listener("after_server_stop")
async def after_stop(app, _):
    pool = getattr(app.ctx, "pool", None)
    if pool:
        pool.close()
        await pool.wait_closed()

async def append_raw(body: bytes, log_dir: str, ts_kst: datetime):
    """ìš”ì²­ ë°”ë”” ì•ì— KST íƒ€ì„ìŠ¤íƒ¬í”„ ë¶™ì—¬ì„œ íŒŒì¼ì— append."""
    date_str = ts_kst.strftime("%Y%m%d")
    ts_str = ts_kst.strftime("%Y-%m-%d %H:%M:%S")
    path = os.path.join(log_dir, f"{date_str}.log")
    async with aiofiles.open(path, "ab") as f:
        line = f"[{ts_str}] ".encode() + (body or b"")
        if not line.endswith(b"\n"):
            line += b"\n"
        await f.write(line)


async def insert_db(request: Request, ts_kst: datetime, body: bytes):
    """
    JSONì´ë©´ ê° í•„ë“œ ë§¤í•‘í•˜ì—¬ router_infoì— INSERT.
    JSON íŒŒì‹± ì‹¤íŒ¨ë©´ raw_textì— ì›ë¬¸ ì €ì¥.
    """
    pool = app.ctx.pool
    client_ip = request.remote_addr or None
    ts_str = ts_kst.strftime("%Y-%m-%d %H:%M:%S")

    # ê¸°ë³¸ row dict
    row = {
        "ts_kst": ts_str,
        "datetime_str": None,
        "msisdn": None,
        "system": None,
        "plmn": None,
        "band": None,
        "earfcn_dl": None,
        "earfcn_ul": None,
        "bandwidth": None,
        "cell_id": None,
        "pci": None,
        "drx": None,
        "rsrp": None,
        "rsrq": None,
        "rssi": None,
        "tac": None,
        "sinr": None,
        "rrc_st": None,
        "emc_st": None,
        "scell_band": None,
        "scell_bw": None,
        "scell_status": None,
        "latitude": None,
        "longitude": None,
        "ip_v4": None,
        "client_ip": client_ip,
        "raw_json": None,   # ë¬¸ìì—´(JSON)ë¡œ ì €ì¥
        "raw_text": None,
    }

    # JSON íŒŒì‹±
    try:
        payload = json.loads(body.decode("utf-8"))
        # ë“¤ì–´ì˜¨ JSON í‚¤ ê·¸ëŒ€ë¡œ ë§¤í•‘ (ëŒ€ì†Œë¬¸ì ìœ ì§€)
        row["datetime_str"] = payload.get("DATETIME")
        row["msisdn"]       = payload.get("MSISDN")
        row["system"]       = payload.get("SYSTEM")
        row["plmn"]         = payload.get("PLMN")
        row["band"]         = payload.get("Band")
        row["earfcn_dl"]    = payload.get("EARFCN_DL")
        row["earfcn_ul"]    = payload.get("EARFCN_UL")
        row["bandwidth"]    = payload.get("Bandwidth")
        row["cell_id"]      = payload.get("Cell_ID")
        row["pci"]          = payload.get("PCI")
        row["drx"]          = payload.get("DRX")
        row["rsrp"]         = payload.get("RSRP")
        row["rsrq"]         = payload.get("RSRQ")
        row["rssi"]         = payload.get("RSSI")
        row["tac"]          = payload.get("TAC")
        row["sinr"]         = payload.get("SINR")
        row["rrc_st"]       = payload.get("RRC_ST")
        row["emc_st"]       = payload.get("EMC_ST")
        row["scell_band"]   = payload.get("SCELL_BAND")
        row["scell_bw"]     = payload.get("SCELL_BW")
        row["scell_status"] = payload.get("SCELL_STATUS")
        row["latitude"]     = payload.get("LATITUDE")
        row["longitude"]    = payload.get("LONGITUDE")
        row["ip_v4"]        = payload.get("IP_v4")
        # ì›ë³¸ JSON ë¬¸ìì—´ ë³´ê´€(ì´ëª¨ì§€/í•œê¸€ ë³´ì¡´)
        row["raw_json"]     = json.dumps(payload, ensure_ascii=False)
    except Exception:
        # JSONì´ ì•„ë‹ˆë©´ ì›ë¬¸ì„ raw_textì— ì €ì¥
        row["raw_text"]     = body.decode("utf-8", errors="replace")

    sql = """
    INSERT INTO `router_info` (
      `ts_kst`, `datetime_str`, `msisdn`, `system`, `plmn`, `band`,
      `earfcn_dl`, `earfcn_ul`, `bandwidth`, `cell_id`, `pci`, `drx`,
      `rsrp`, `rsrq`, `rssi`, `tac`, `sinr`, `rrc_st`, `emc_st`,
      `scell_band`, `scell_bw`, `scell_status`, `latitude`, `longitude`,
      `ip_v4`, `client_ip`, `raw_json`, `raw_text`
    ) VALUES (
      %(ts_kst)s, %(datetime_str)s, %(msisdn)s, %(system)s, %(plmn)s, %(band)s,
      %(earfcn_dl)s, %(earfcn_ul)s, %(bandwidth)s, %(cell_id)s, %(pci)s, %(drx)s,
      %(rsrp)s, %(rsrq)s, %(rssi)s, %(tac)s, %(sinr)s, %(rrc_st)s, %(emc_st)s,
      %(scell_band)s, %(scell_bw)s, %(scell_status)s, %(latitude)s, %(longitude)s,
      %(ip_v4)s, %(client_ip)s, %(raw_json)s, %(raw_text)s
    )
    """
    async with pool.acquire() as conn:
        async with conn.cursor() as cur:
            # 1) devices ìë™ ë“±ë¡ (VALUES() íê¸° â†’ alias ë°©ì‹)
            if row["msisdn"]:
                #25.12.16 kdh
                # await cur.execute(
                #     "INSERT IGNORE INTO devices (msisdn) VALUES (%s) AS new "
                #     "ON DUPLICATE KEY UPDATE msisdn = new.msisdn",
                #     (row["msisdn"],)
                # )
                await cur.execute(
                    """
                    INSERT INTO devices (msisdn, dormant, dormant_at) VALUES (%s, 0, NULL) AS new
                    ON DUPLICATE KEY UPDATE
                    msisdn = new.msisdn,
                    dormant = 0,
                    dormant_at = NULL
                    """,
                    (row["msisdn"],)
                )
            # 2) router_info ë³¸ë¬¸ INSERT ì‹¤í–‰ (â† ì´ê²Œ ë¹ ì ¸ ìˆì—ˆìŒ)
            await cur.execute(sql, row)


# ë¼ìš°íŠ¸ ì´ë¦„(name) ëª…ì‹œí•˜ì—¬ ì¤‘ë³µ ë°©ì§€
@app.route("/<path:path>", methods=["POST", "PUT", "PATCH"], name="log_any_path")
@app.route("/", methods=["POST", "PUT", "PATCH"], name="log_any_root")
async def log_any(request: Request, path: str = ""):
    ts_kst = datetime.now(tz=KST)
    body = request.body or b""

    # 1) íŒŒì¼ ë¡œê·¸
    await append_raw(body, app.ctx.log_dir, ts_kst)

    # 2) DB ì €ì¥ (ì—ëŸ¬ ë‚˜ë„ ì‘ë‹µì€ OK, íŒŒì¼ë¡œê·¸ì—ë§Œ ë‚¨ê¹€)
    try:
        await insert_db(request, ts_kst, body)
    except Exception as e:
        err = f"[{ts_kst.strftime('%Y-%m-%d %H:%M:%S')}] DB_ERROR: {repr(e)}\n"
        async with aiofiles.open(os.path.join(app.ctx.log_dir, f"{ts_kst.strftime('%Y%m%d')}.log"), "ab") as f:
            await f.write(err.encode())

    return response.text("ok\n")

# 1) ê¸°ê¸° ë¦¬ìŠ¤íŠ¸

# 25.12.16 kdh
#@app.get("/api/msisdns", name="list_msisdns")
# async def list_msisdns(_):
#     # KST ê¸°ì¤€ ìµœê·¼ 24ì‹œê°„ ì»·ì˜¤í”„
#     cutoff_dt = (datetime.now(tz=KST) - timedelta(hours=24)).strftime("%Y-%m-%d %H:%M:%S")

#     sql = """
#     SELECT
#       d.msisdn,
#       d.alias,
#       EXISTS(
#         SELECT 1 FROM router_info r
#         WHERE r.msisdn = d.msisdn
#           AND r.ts_kst >= %s
#       ) AS has_recent
#     FROM devices d
#     /* ë‹‰ë„¤ì„ì´ ìˆëŠ” ê¸°ê¸°ê°€ ë¨¼ì €, ë‹‰ë„¤ì„ë¼ë¦¬ëŠ” ì‚¬ì „ìˆœ, ë‹‰ë„¤ì„ ì—†ëŠ” ê¸°ê¸°ëŠ” ë§¨ ë’¤ì—ì„œ msisdn ì‚¬ì „ìˆœ */
#     ORDER BY
#       CASE WHEN d.alias IS NULL OR d.alias = '' THEN 1 ELSE 0 END ASC,
#       d.alias ASC,
#       d.msisdn ASC
#     """

#     async with app.ctx.pool.acquire() as conn:
#         async with conn.cursor(aiomysql.DictCursor) as cur:
#             await cur.execute(sql, (cutoff_dt,))
#             rows = await cur.fetchall()

#     # has_recentì„ boolë¡œ ë³€í™˜í•´ì„œ ë‚´ë ¤ì£¼ê¸°
#     devices = [{"msisdn": r["msisdn"], "alias": r["alias"], "has_recent": bool(r["has_recent"])} for r in rows] 
#     return response.json({"devices": devices})

@app.get("/api/msisdns", name="list_msisdns")
async def list_msisdns(req: Request):
    include_dormant = (req.args.get("include_dormant", "0") in ("1", "true", "yes"))

    # KST ê¸°ì¤€ ìµœê·¼ 24ì‹œê°„ ì»·ì˜¤í”„
    cutoff_dt = (datetime.now(tz=KST) - timedelta(hours=24)).strftime("%Y-%m-%d %H:%M:%S")

    where_dormant = "" if include_dormant else "WHERE d.dormant = 0"

    sql = f"""
    SELECT
      d.msisdn,
      d.alias,
      d.dormant,
      EXISTS(
        SELECT 1 FROM router_info r
        WHERE r.msisdn = d.msisdn
          AND r.ts_kst >= %s
      ) AS has_recent
    FROM devices d
    {where_dormant}
    ORDER BY
      CASE WHEN d.alias IS NULL OR d.alias = '' THEN 1 ELSE 0 END ASC,
      d.alias ASC,
      d.msisdn ASC
    """

    async with app.ctx.pool.acquire() as conn:
        async with conn.cursor(aiomysql.DictCursor) as cur:
            await cur.execute(sql, (cutoff_dt,))
            rows = await cur.fetchall()

    devices = [{
        "msisdn": r["msisdn"],
        "alias": r["alias"],
        "dormant": bool(r["dormant"]),
        "has_recent": bool(r["has_recent"]),
    } for r in rows]

    return response.json({"devices": devices})


# 2) ìµœê·¼ Nì¼(ê¸°ë³¸ 7ì¼) ì¼ë³„ í‰ê· 
#   /api/metrics/daily_avg?msisdn=0123&days=7
@app.get("/api/metrics/daily_avg", name="daily_avg")
async def daily_avg(req: Request):
    msisdn = req.args.get("msisdn")
    raw_days = (req.args.get("days", "7") or "7").strip()
    # "7ì¼" ê°™ì€ ì¼€ì´ìŠ¤ ë°©ì–´(ìˆ«ì/ì ë§Œ ë‚¨ê¹€)
    # raw_days = "".join(ch for ch in raw_days if (ch.isdigit() or ch == "."))
    days = int(float(raw_days or 7))
    # days = max(1, min(days, 365))  # ìƒí•œë„ ê±¸ì–´ë‘ê¸°(ì„ íƒ)
    start = req.args.get("start")  # YYYY-MM-DD (ì˜µì…˜)
    end   = req.args.get("end")    # YYYY-MM-DD (ì˜µì…˜)

    if not msisdn:
        raise InvalidUsage("msisdn is required")

    # âœ… start/endê°€ ë“¤ì–´ì˜¤ë©´ ë‚ ì§œ ë²”ìœ„ ì‚¬ìš©, ì•„ë‹ˆë©´ days ê¸°ë°˜ ìµœê·¼ Nì¼
    if start and end:
        sql = r"""
        SELECT
          DATE(`ts_kst`) AS d,
          AVG(CAST(NULLIF(`rsrp`,'')  AS DECIMAL(10,3))) AS rsrp_avg,
          AVG(CAST(NULLIF(`rsrq`,'')  AS DECIMAL(10,3))) AS rsrq_avg,
          AVG(CAST(NULLIF(`sinr`,'')  AS DECIMAL(10,3))) AS sinr_avg,
          AVG(CAST(NULLIF(`rssi`,'')  AS DECIMAL(10,3))) AS router_rssi_avg,
          NULL AS dl_mbps_avg,
          NULL AS ul_mbps_avg,
          NULL AS router_temp_avg
        FROM `router_info`
        WHERE `msisdn` = %s
          AND `ts_kst` >= %s
          AND `ts_kst` < DATE_ADD(%s, INTERVAL 1 DAY)
        GROUP BY DATE(`ts_kst`)
        ORDER BY DATE(`ts_kst`);
        """
        params = (msisdn, start, end)
    else:
        sql = r"""
        SELECT
          DATE(`ts_kst`) AS d,
          AVG(CAST(NULLIF(`rsrp`,'')  AS DECIMAL(10,3))) AS rsrp_avg,
          AVG(CAST(NULLIF(`rsrq`,'')  AS DECIMAL(10,3))) AS rsrq_avg,
          AVG(CAST(NULLIF(`sinr`,'')  AS DECIMAL(10,3))) AS sinr_avg,
          AVG(CAST(NULLIF(`rssi`,'')  AS DECIMAL(10,3))) AS router_rssi_avg,
          NULL AS dl_mbps_avg,
          NULL AS ul_mbps_avg,
          NULL AS router_temp_avg
        FROM `router_info`
        WHERE `msisdn` = %s
          AND `ts_kst` >= (CURRENT_DATE - INTERVAL %s DAY)
        GROUP BY DATE(`ts_kst`)
        ORDER BY DATE(`ts_kst`);
        """
        params = (msisdn, days)

    try:
        async with app.ctx.pool.acquire() as conn:
            async with conn.cursor(aiomysql.DictCursor) as cur:
                await cur.execute(sql, params)
                rows = await cur.fetchall()

        # d: date â†’ string, ìˆ˜ì¹˜ê°’ â†’ float
        for r in rows:
            if hasattr(r.get("d"), "strftime"):
                r["d"] = r["d"].strftime("%Y-%m-%d")
            for k in ("rsrp_avg", "rsrq_avg", "sinr_avg", "router_rssi_avg",
                      "dl_mbps_avg", "ul_mbps_avg", "router_temp_avg"):
                v = r.get(k)
                if v is not None:
                    r[k] = float(v)

        return response.json({"msisdn": msisdn, "days": days, "start": start, "end": end, "data": rows})
    except Exception as e:
        ts = datetime.now(tz=KST).strftime("%Y-%m-%d %H:%M:%S")
        async with aiofiles.open(os.path.join(app.ctx.log_dir, f"{datetime.now(tz=KST).strftime('%Y%m%d')}.log"), "ab") as f:
            await f.write(f"[{ts}] DAILY_AVG_ERROR {repr(e)}\n".encode())
        return response.json({"error": "query_failed", "detail": repr(e)}, status=500)

# 2-1 ì›ì‹œ ì‹œê³„ì—´ ê·¸ë˜í”„


# 2-1) ìµœê·¼ Nì¼(ê¸°ë³¸ 7ì¼) ì‹œê°„ë³„ í‰ê· 
#   /api/metrics/hourly_avg?msisdn=0123&start=2025-12-01&end=2025-12-18
#   /api/metrics/hourly_avg?msisdn=0123&days=7
@app.get("/api/metrics/hourly_avg", name="hourly_avg")
async def hourly_avg(req: Request):
    msisdn = req.args.get("msisdn")
    raw_days = (req.args.get("days", "7") or "7").strip()
    # "7ì¼" ê°™ì€ ì…ë ¥ ë°©ì–´: ìˆ«ì/ì ë§Œ ë‚¨ê¹€ (í•„ìš”í•˜ë©´ ì‚¬ìš©)
    # raw_days = "".join(ch for ch in raw_days if (ch.isdigit() or ch == "."))
    days = int(float(raw_days or 7))

    start = req.args.get("start")  # YYYY-MM-DD (ì˜µì…˜)
    end   = req.args.get("end")    # YYYY-MM-DD (ì˜µì…˜)

    if not msisdn:
        raise InvalidUsage("msisdn is required")

    # ì‹œê°„ ë²„í‚· í‘œí˜„ì‹: SELECT/GROUP BY/ORDER BY ëª¨ë‘ ë™ì¼í•˜ê²Œ ì‚¬ìš©
    # (only_full_group_by ì•ˆì „)
    if start and end:
        sql = r"""
        SELECT
          DATE_FORMAT(`ts_kst`, '%%Y-%%m-%%d %%H:00:00') AS h,
          AVG(CAST(NULLIF(`rsrp`,'')  AS DECIMAL(10,3))) AS rsrp_avg,
          AVG(CAST(NULLIF(`rsrq`,'')  AS DECIMAL(10,3))) AS rsrq_avg,
          AVG(CAST(NULLIF(`sinr`,'')  AS DECIMAL(10,3))) AS sinr_avg,
          AVG(CAST(NULLIF(`rssi`,'')  AS DECIMAL(10,3))) AS router_rssi_avg,
          NULL AS dl_mbps_avg,
          NULL AS ul_mbps_avg,
          NULL AS router_temp_avg
        FROM `router_info`
        WHERE `msisdn` = %s
          AND `ts_kst` >= %s
          AND `ts_kst` < DATE_ADD(%s, INTERVAL 1 DAY)
        GROUP BY h
        ORDER BY h ASC;
        """
        params = (msisdn, start, end)
    else:
        sql = r"""
        SELECT
          DATE_FORMAT(`ts_kst`, '%%Y-%%m-%%d %%H:00:00') AS h,
          AVG(CAST(NULLIF(`rsrp`,'')  AS DECIMAL(10,3))) AS rsrp_avg,
          AVG(CAST(NULLIF(`rsrq`,'')  AS DECIMAL(10,3))) AS rsrq_avg,
          AVG(CAST(NULLIF(`sinr`,'')  AS DECIMAL(10,3))) AS sinr_avg,
          AVG(CAST(NULLIF(`rssi`,'')  AS DECIMAL(10,3))) AS router_rssi_avg,
          NULL AS dl_mbps_avg,
          NULL AS ul_mbps_avg,
          NULL AS router_temp_avg
        FROM `router_info`
        WHERE `msisdn` = %s
          AND `ts_kst` >= (CURRENT_TIMESTAMP - INTERVAL %s DAY)
        GROUP BY h
        ORDER BY h ASC;
        """
        params = (msisdn, days)

    try:
        async with app.ctx.pool.acquire() as conn:
            async with conn.cursor(aiomysql.DictCursor) as cur:
                await cur.execute(sql, params)
                rows = await cur.fetchall()

        # JSON ì§ë ¬í™”(Decimal -> float)
        for r in rows:
            for k in (
                "rsrp_avg", "rsrq_avg", "sinr_avg", "router_rssi_avg",
                "dl_mbps_avg", "ul_mbps_avg", "router_temp_avg"
            ):
                v = r.get(k)
                if v is not None:
                    r[k] = float(v)

        return response.json({
            "msisdn": msisdn,
            "days": days,
            "start": start,
            "end": end,
            "data": rows
        })
    except Exception as e:
        ts = datetime.now(tz=KST).strftime("%Y-%m-%d %H:%M:%S")
        async with aiofiles.open(
            os.path.join(app.ctx.log_dir, f"{datetime.now(tz=KST).strftime('%Y%m%d')}.log"),
            "ab"
        ) as f:
            await f.write(f"[{ts}] HOURLY_AVG_ERROR {repr(e)}\n".encode())
        return response.json({"error": "query_failed", "detail": repr(e)}, status=500)

@app.get("/api/metrics/raw", name="metrics_raw")
async def metrics_raw(req: Request):
    """
    ìµœê·¼ Nì¼ ë˜ëŠ” ì§€ì • ë²”ìœ„ì˜ ì›ì‹œ ì‹œê³„ì—´ ë°ì´í„° + ëˆ„ë½ êµ¬ê°„ ì„ì˜ ìƒì„±.

    Query:
      - msisdn: í•„ìˆ˜
      - days  : ê¸°ë³¸ 7 (recent ëª¨ë“œ)
      - start, end: YYYY-MM-DD (range ëª¨ë“œ)

    ì„ì˜ ìƒì„± ê·œì¹™:
      - ë‚´ë¶€ êµ¬ê°„: (ë‹¤ìŒì‹¤ì œì‹œê°„ - ì´ì „ì‹¤ì œì‹œê°„) / 5ë¶„  => ê·¸ ê°’ì—ì„œ -1 í•œ ê°œìˆ˜ë§Œí¼ ìƒì„±
      - ë§ˆì§€ë§‰ êµ¬ê°„:
          * recent ëª¨ë“œ: (í˜„ì¬ì‹œê°„ - ë§ˆì§€ë§‰ì‹¤ì œì‹œê°„) / 5ë¶„  => -1 ê°œ
          * range ëª¨ë“œ: (ë²”ìœ„ì¢…ë£Œì‹œê°„( end+1ì¼ ) - ë§ˆì§€ë§‰ì‹¤ì œì‹œê°„) / 5ë¶„  => -1 ê°œ
      - ì„ì˜ ìƒì„± ê°’:
          RSRP = -125, RSRQ = -15, SINR = 5, RSSI = -100
    """
    msisdn = req.args.get("msisdn")
    days   = int(req.args.get("days", "7"))
    start  = req.args.get("start")
    end    = req.args.get("end")

    if not msisdn:
        raise InvalidUsage("msisdn is required")

    # 1) ì¡°íšŒ êµ¬ê°„ SQL / íŒŒë¼ë¯¸í„° ê²°ì •
    if start and end:
        # ë‚ ì§œ ì§€ì • ëª¨ë“œ: [start, end+1ì¼) êµ¬ê°„
        sql = """
        SELECT
          ts_kst,
          CAST(NULLIF(rsrp,'')  AS DECIMAL(10,3)) AS rsrp,
          CAST(NULLIF(rsrq,'')  AS DECIMAL(10,3)) AS rsrq,
          CAST(NULLIF(sinr,'')  AS DECIMAL(10,3)) AS sinr,
          CAST(NULLIF(rssi,'')  AS DECIMAL(10,3)) AS router_rssi
        FROM router_info
        WHERE msisdn = %s
          AND ts_kst >= %s
          AND ts_kst < DATE_ADD(%s, INTERVAL 1 DAY)
        ORDER BY ts_kst ASC
        """
        params = (msisdn, start, end)
        # tail ì±„ì›Œ ë„£ì„ ë•Œ ì‚¬ìš©í•  â€œë ê²½ê³„â€
        try:
            range_end_boundary = datetime.strptime(end, "%Y-%m-%d").replace(tzinfo=KST) + timedelta(days=1)
        except Exception:
            range_end_boundary = datetime.now(tz=KST)
    else:
        # ìµœê·¼ Nì¼ ëª¨ë“œ: now- Nì¼ ~ now
        cutoff = (datetime.now(tz=KST) - timedelta(days=days)).strftime("%Y-%m-%d %H:%M:%S")
        sql = """
        SELECT
          ts_kst,
          CAST(NULLIF(rsrp,'')  AS DECIMAL(10,3)) AS rsrp,
          CAST(NULLIF(rsrq,'')  AS DECIMAL(10,3)) AS rsrq,
          CAST(NULLIF(sinr,'')  AS DECIMAL(10,3)) AS sinr,
          CAST(NULLIF(rssi,'')  AS DECIMAL(10,3)) AS router_rssi
        FROM router_info
        WHERE msisdn = %s
          AND ts_kst >= %s
        ORDER BY ts_kst ASC
        """
        params = (msisdn, cutoff)
        range_end_boundary = datetime.now(tz=KST)

    try:
        async with app.ctx.pool.acquire() as conn:
            async with conn.cursor(aiomysql.DictCursor) as cur:
                await cur.execute(sql, params)
                rows = await cur.fetchall()

        # 2) ê¸°ë³¸ í¬ì¸íŠ¸: ì‹¤ì œ ìˆ˜ì‹ ê°’
        def to_float(v):
            if v is None:
                return None
            try:
                return float(v)
            except Exception:
                return None

        raw_points = []
        for r in rows:
            ts_dt = r["ts_kst"]
            # í˜¹ì‹œ timezone ì—†ëŠ” datetimeì´ë©´ KST ë¶™ì—¬ì£¼ê¸°
            if isinstance(ts_dt, datetime) and ts_dt.tzinfo is None:
                ts_dt = ts_dt.replace(tzinfo=KST)
            raw_points.append({
                "ts": ts_dt,
                "rsrp": to_float(r.get("rsrp")),
                "rsrq": to_float(r.get("rsrq")),
                "sinr": to_float(r.get("sinr")),
                "router_rssi": to_float(r.get("router_rssi")),
                "is_fake": False,
            })

        # 3) ëˆ„ë½ êµ¬ê°„ì— ì„ì˜ í¬ì¸íŠ¸ ì‚½ì…
        filled = []
        FIVE_MIN = 300  # ì´ˆ

        # (1) ì‹¤ì œ í¬ì¸íŠ¸ë“¤ ì‚¬ì´
        prev = None
        for p in raw_points:
            if prev is not None:
                delta_sec = (p["ts"] - prev["ts"]).total_seconds()
                # ë‘ í¬ì¸íŠ¸ ì‚¬ì´ì— ëª‡ ê°œì˜ 5ë¶„ ê°„ê²©ì´ ë“¤ì–´ê°€ë‚˜?
                #   ex) 30ë¶„ ì°¨ì´ => 30/5 = 6 â†’ 6-1 = 5ê°œ ìƒì„±
                gaps = int(delta_sec // FIVE_MIN) - 1
                if gaps > 0:
                    for i in range(1, gaps + 1):
                        ts_fake = prev["ts"] + timedelta(minutes=5 * i)
                        filled.append({
                            "ts": ts_fake,
                            "rsrp": -125.0,
                            "rsrq": -15.0,
                            "sinr": 5.0,
                            "router_rssi": -100.0,
                            "is_fake": True,
                        })
            filled.append(p)
            prev = p

        # (2) ë§ˆì§€ë§‰ ì‹¤ì œ í¬ì¸íŠ¸ ì´í›„ ~ now (ë˜ëŠ” end+1ì¼) ì‚¬ì´
        if raw_points:
            last = raw_points[-1]

            # ì›ë˜ ë²”ìœ„ì˜ ë(ë‚ ì§œì§€ì •ì´ë©´ end+1ì¼, ìµœê·¼ëª¨ë“œë©´ now ê·¼ì²˜)ì´ë‘
            # "í˜„ì¬ ì‹œê°„" ì¤‘ ë” ì´ë¥¸ ìª½ê¹Œì§€ë§Œ ì±„ìš´ë‹¤.
            now_kst = datetime.now(tz=KST)
            tail_to = range_end_boundary
            if tail_to > now_kst:
                tail_to = now_kst

            # tail_to ê°€ ë§ˆì§€ë§‰ í¬ì¸íŠ¸ë³´ë‹¤ ê³¼ê±°ë©´ ì±„ìš°ì§€ ì•ŠìŒ
            if tail_to > last["ts"]:
                delta_sec = (tail_to - last["ts"]).total_seconds()
                gaps_tail = int(delta_sec // FIVE_MIN) - 1
                if gaps_tail > 0:
                    for i in range(1, gaps_tail + 1):
                        ts_fake = last["ts"] + timedelta(minutes=5 * i)
                        if ts_fake >= tail_to:
                            break
                        filled.append({
                            "ts": ts_fake,
                            "rsrp": -125.0,
                            "rsrq": -15.0,
                            "sinr": 5.0,
                            "router_rssi": -100.0,
                            "is_fake": True,
                        })
        else:
            filled = []  # ë°ì´í„° ìì²´ê°€ ì—†ìœ¼ë©´ ë¹ˆ ë¦¬ìŠ¤íŠ¸

        # 4) ì‹œê°„ ìˆœ ì •ë ¬ (ì¤‘ê°„ì— ë¼ì›Œë„£ì—ˆìœ¼ë‹ˆ í•œë²ˆ ì •ë ¬)
        filled.sort(key=lambda x: x["ts"])

        # 5) JSON ì§ë ¬í™”ë¥¼ ìœ„í•´ ë¬¸ìì—´ë¡œ ë³€í™˜
        out = []
        for p in filled:
            out.append({
                "ts": p["ts"].strftime("%Y-%m-%d %H:%M:%S"),
                "rsrp": p["rsrp"],
                "rsrq": p["rsrq"],
                "sinr": p["sinr"],
                "router_rssi": p["router_rssi"],
                # is_fakeëŠ” ë‚˜ì¤‘ì— í•„ìš”í•˜ë©´ í”„ë¡ íŠ¸ì—ì„œ ìƒ‰ ë¶„ë¦¬í•˜ëŠ”ìš©
                "is_fake": p["is_fake"],
            })

        return response.json({
            "msisdn": msisdn,
            "days": days,
            "start": start,
            "end": end,
            "data": out,
        })
    except Exception as e:
        ts = datetime.now(tz=KST).strftime("%Y-%m-%d %H:%M:%S")
        async with aiofiles.open(os.path.join(app.ctx.log_dir, f"{datetime.now(tz=KST).strftime('%Y%m%d')}.log"), "ab") as f:
            await f.write(f"[{ts}] METRICS_RAW_ERROR {repr(e)}\n".encode())
        return response.json({"error": "query_failed", "detail": repr(e)}, status=500)
    
# 3) ê¸°ê°„ë³„ ìƒì„¸ ë ˆì½”ë“œ í‘œ ì¡°íšŒ(í˜ì´ì§•)
#   /api/records?msisdn=...&start=2025-09-01&end=2025-09-12&page=1&page_size=200
@app.get("/api/records", name="records")
async def records(req: Request):
    msisdn = req.args.get("msisdn")
    start  = req.args.get("start")  # YYYY-MM-DD
    end    = req.args.get("end")    # YYYY-MM-DD
    page   = int(req.args.get("page", "1"))
    size   = int(req.args.get("page_size", "200"))
    order = (req.args.get("order") or "desc").lower()
    order_sql = "ASC" if order == "asc" else "DESC"
    if not (msisdn and start and end):
        raise InvalidUsage("msisdn, start, end are required")

    # âœ… ë°©ì–´: ìŒìˆ˜/ë§ë„ì•ˆë˜ëŠ” ê°’ ë°©ì§€ ë° ìƒí•œ
    page   = max(1, page)
    size   = max(1, min(size, 1000))  # ìµœëŒ€ 1000í–‰
    offset = (page - 1) * size

    # âœ… LIMIT/OFFSETì€ ì•ˆì „í•˜ê²Œ ì •ìˆ˜ ì‚½ì…, ë‚˜ë¨¸ì§€ëŠ” %s ë°”ì¸ë”©
    sql = f"""
    SELECT
      `id`,`ts_kst`,`datetime_str`,`system`,`plmn`,`band`,`earfcn_dl`,`earfcn_ul`,
      `bandwidth`,`cell_id`,`pci`,`drx`,`rsrp`,`rsrq`,`rssi`,`tac`,`sinr`,`rrc_st`,`emc_st`,
      `scell_band`,`scell_bw`,`scell_status`,`latitude`,`longitude`,`ip_v4`
    FROM `router_info`
    WHERE `msisdn`=%s
      AND `ts_kst` >= %s
      AND `ts_kst` < DATE_ADD(%s, INTERVAL 1 DAY)
    ORDER BY `ts_kst` {order_sql}
    LIMIT {size} OFFSET {offset}
    """

    async with app.ctx.pool.acquire() as conn:
        async with conn.cursor(aiomysql.DictCursor) as cur:
            # (ì„ íƒ) KST ì„¸ì…˜ íƒ€ì„ì¡´ ê³ ì •ì´ í•„ìš”í•˜ë©´ ì•„ë˜ ì¤„ í™œì„±í™”
            # await cur.execute("SET time_zone = '+09:00'")

            # â–¶ ì—¬ê¸°ì„œëŠ” %s ìë¦¬í‘œì‹œì 3ê°œë§Œ ì „ë‹¬
            await cur.execute(sql, (msisdn, start, end))
            rows = await cur.fetchall()

            # datetime ì§ë ¬í™” ì•ˆì „í™”
            for r in rows:
                if isinstance(r.get("ts_kst"), datetime):
                    r["ts_kst"] = r["ts_kst"].strftime("%Y-%m-%d %H:%M:%S")

            # total countëŠ” ê·¸ëŒ€ë¡œ %s ì„¸ ê°œë§Œ ì‚¬ìš©
            await cur.execute("""
                SELECT COUNT(*) AS cnt
                FROM `router_info`
                WHERE `msisdn`=%s
                  AND `ts_kst` >= %s
                  AND `ts_kst` < DATE_ADD(%s, INTERVAL 1 DAY)
            """, (msisdn, start, end))
            total = (await cur.fetchone())["cnt"]

            return response.json({
                "msisdn": msisdn, "start": start, "end": end,
                "page": page, "page_size": size, "total": total, "rows": rows
            })
        

@app.get("/api/records/csv", name="records_csv")
async def records_csv(req: Request):
    msisdn = req.args.get("msisdn")
    start  = req.args.get("start")    # YYYY-MM-DD
    end    = req.args.get("end")      # YYYY-MM-DD
    if not (msisdn and start and end):
        raise InvalidUsage("msisdn, start, end are required")

    # ğŸ”½ ì •ë ¬ íŒŒë¼ë¯¸í„° í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸ (SQL ì¸ì ì…˜ ë°©ì§€)
    order = (req.args.get("order") or "desc").lower()
    order_sql = "ASC" if order == "asc" else "DESC"

    sep = (req.args.get("sep") or "comma").lower()
    if sep in ("semicolon", "semi", "sc"):
        delimiter = ";"
        ext = "csv"
    elif sep in ("tab", "tsv"):
        delimiter = "\t"
        ext = "tsv"
    else:
        delimiter = ","
        ext = "csv"

    filename = f"router_{msisdn}_{start}_{end}.{ext}"

    headers_cols = [
        "id","ts_kst","datetime_str","system","plmn","band","earfcn_dl","earfcn_ul",
        "bandwidth","cell_id","pci","drx","rsrp","rsrq","rssi","tac","sinr","rrc_st","emc_st",
        "scell_band","scell_bw","scell_status","latitude","longitude","ip_v4"
    ]

    # ğŸ”½ f-string ìœ¼ë¡œ ORDER BYì— {order_sql} ì‚½ì… (ë‚˜ë¨¸ì§€ëŠ” %s ë°”ì¸ë”© ìœ ì§€)
    sql = f"""
    SELECT
      `id`,`ts_kst`,`datetime_str`,`system`,`plmn`,`band`,`earfcn_dl`,`earfcn_ul`,
      `bandwidth`,`cell_id`,`pci`,`drx`,`rsrp`,`rsrq`,`rssi`,`tac`,`sinr`,`rrc_st`,`emc_st`,
      `scell_band`,`scell_bw`,`scell_status`,`latitude`,`longitude`,`ip_v4`
    FROM `router_info`
    WHERE `msisdn`=%s
      AND `ts_kst` >= %s
      AND `ts_kst` < DATE_ADD(%s, INTERVAL 1 DAY)
    ORDER BY `ts_kst` {order_sql}
    """

    # CSVë¥¼ ë©”ëª¨ë¦¬ì—ì„œ ìƒì„±
    sio = io.StringIO(newline="")
    # â˜… ì—‘ì…€ í˜¸í™˜ì„ ìœ„í•´ êµ¬ë¶„ì/ì¤„ë°”ê¿ˆ ëª…ì‹œ
    writer = csv.writer(
        sio,
        delimiter=delimiter,
        lineterminator="\r\n",   # CRLF
        quoting=csv.QUOTE_MINIMAL,
        quotechar='"',
        escapechar=None,
    )
    writer.writerow(headers_cols)  # í—¤ë”

    async with app.ctx.pool.acquire() as conn:
        async with conn.cursor() as cur:
            # í•„ìš” ì‹œ KST ê³ ì •: await cur.execute("SET time_zone = '+09:00'")
            await cur.execute(sql, (msisdn, start, end))
            while True:
                rows = await cur.fetchmany(2000)
                if not rows:
                    break
                for row in rows:
                    row = list(row)
                    # ts_kst: datetime â†’ ë¬¸ìì—´
                    if isinstance(row[1], datetime):
                        row[1] = row[1].strftime("%Y-%m-%d %H:%M:%S")
                    writer.writerow(row)

    content = "\ufeff" + sio.getvalue()  # UTF-8 BOM
    headers_resp = {
        "Content-Type": "text/csv; charset=utf-8",
        "Content-Disposition": f'attachment; filename="{filename}"',
        "Cache-Control": "no-store",
    }
    return response.raw(content.encode("utf-8"), headers=headers_resp)

@app.post("/api/devices/alias", name="set_alias")
async def set_alias(req: Request):
    """
    Body(JSON): { "msisdn": "01234...", "alias": "í˜„ì¥1í˜¸ê¸°" }
    aliasê°€ ë¹ˆë¬¸ìì—´/Noneì´ë©´ NULLë¡œ ì €ì¥(ë³„ì¹­ ì œê±°).
    """
    try:
        data = req.json
    except Exception:
        raise InvalidUsage("invalid json")

    msisdn = (data or {}).get("msisdn")
    alias  = (data or {}).get("alias")
    if not msisdn:
        raise InvalidUsage("msisdn is required")

    # ë¹ˆ ë³„ì¹­ â†’ NULL ì €ì¥
    if alias is not None:
        alias = alias.strip()
        if alias == "":
            alias = None

    async with app.ctx.pool.acquire() as conn:
        async with conn.cursor() as cur:
            # INSERT .. ON DUPLICATE (VALUES ì—†ì´ íŒŒë¼ë¯¸í„°ë¡œ ë‘ ë²ˆ ë°”ì¸ë”©)
            sql = """
            INSERT INTO devices (msisdn, alias) VALUES (%s, %s)
            ON DUPLICATE KEY UPDATE alias = %s
            """
            await cur.execute(sql, (msisdn, alias, alias))

    return response.json({"ok": True, "msisdn": msisdn, "alias": alias})

#25.12.16 kdh
# @app.delete("/api/devices", name="delete_device")
# async def delete_device(req: Request):
#     """
#     Query params:
#       - msisdn: í•„ìˆ˜
#       - cascade=1 ì´ë©´ router_info í–‰ë„ ê°™ì´ ì‚­ì œ(ì£¼ì˜: ë°ì´í„° ì˜êµ¬ ì‚­ì œ)
#     """
#     msisdn = req.args.get("msisdn")
#     cascade = req.args.get("cascade", "0") in ("1", "true", "yes")

#     if not msisdn:
#         raise InvalidUsage("msisdn is required")

#     async with app.ctx.pool.acquire() as conn:
#         async with conn.cursor() as cur:
#             if cascade:
#                 # ëª¨ë“  ì—°ê´€ ë°ì´í„°ê¹Œì§€ ì‚­ì œ (ì£¼ì˜!)
#                 await cur.execute("DELETE FROM router_info WHERE msisdn=%s", (msisdn,))
#             # devices ëª©ë¡ì—ì„œ ì œê±°
#             await cur.execute("DELETE FROM devices WHERE msisdn=%s", (msisdn,))

#     return response.json({"ok": True, "msisdn": msisdn, "cascade": cascade})

@app.delete("/api/devices", name="delete_device")
async def delete_device(req: Request):
    """
    Query params:
      - msisdn: í•„ìˆ˜
      - cascade=1 ì´ë©´ router_info í–‰ë„ ê°™ì´ ì‚­ì œ(ì£¼ì˜: ë°ì´í„° ì˜êµ¬ ì‚­ì œ)
        (ìš”êµ¬ì‚¬í•­ìƒ 'íœ´ë©´'ì´ ëª©ì ì´ë©´ cascadeëŠ” ë³´í†µ ì“°ì§€ ì•ŠëŠ” ê²ƒì„ ê¶Œì¥)
    """
    msisdn = req.args.get("msisdn")
    cascade = req.args.get("cascade", "0") in ("1", "true", "yes")

    if not msisdn:
        raise InvalidUsage("msisdn is required")

    async with app.ctx.pool.acquire() as conn:
        async with conn.cursor() as cur:
            if cascade:
                await cur.execute("DELETE FROM router_info WHERE msisdn=%s", (msisdn,))

            # âœ… ì˜êµ¬ì‚­ì œ ëŒ€ì‹  íœ´ë©´ ì²˜ë¦¬
            await cur.execute(
                "UPDATE devices SET dormant=1, dormant_at=NOW() WHERE msisdn=%s",
                (msisdn,)
            )

    return response.json({"ok": True, "msisdn": msisdn, "cascade": cascade, "dormant": True})

# íœ´ë©´ í•´ì œ api
@app.post("/api/devices/activate", name="activate_device")
async def activate_device(req: Request):
    data = req.json or {}
    msisdn = data.get("msisdn")
    if not msisdn:
        raise InvalidUsage("msisdn is required")

    async with app.ctx.pool.acquire() as conn:
        async with conn.cursor() as cur:
            await cur.execute(
                "UPDATE devices SET dormant=0, dormant_at=NULL WHERE msisdn=%s",
                (msisdn,)
            )

    return response.json({"ok": True, "msisdn": msisdn, "dormant": False})

@app.get("/healthz", name="healthz")
async def health(_):
    return response.json({"status": "ok"})


if __name__ == "__main__":
    app.run(host="0.0.0.0", port=35443, access_log=False)
